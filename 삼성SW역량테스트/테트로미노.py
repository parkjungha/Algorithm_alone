n, m = map(int,input().split())
board = [ list(map(int,input().split())) for _ in range(n)]

tetromino = [
    [(0,0),(0,1),(1,0),(1,1)], #ㅁ
    [(0,0),(0,1),(0,2),(0,3)], # ㅡ
    [(0,0),(1,0),(2,0),(3,0)], # ㅣ
    [(0,0),(1,0),(2,0),(2,1)], # L
    [(0,1),(1,1),(2,1),(2,0)], # L 대칭
    [(0,0),(0,1),(0,2),(1,0)],
    [(0,0),(0,1),(0,2),(1,2)],
    [(0,0),(0,1),(1,1),(2,1)],
    [(0,0),(0,1),(1,0),(2,0)], 
    [(1,0),(1,1),(1,2),(0,2)],
    [(0,0),(1,0),(1,1),(1,2)],
    [(0,0),(0,1),(0,2),(1,1)], # ㅜ
    [(1,0),(1,1),(1,2),(0,1)], # ㅗ
    [(1,0),(0,1),(1,1),(2,1)], # ㅓ
    [(0,0),(1,0),(2,0),(1,1)], # ㅏ
    [(0,0),(1,0),(1,1),(2,1)], 
    [(0,1),(1,0),(1,1),(2,0)],
    [(0,0),(0,1),(1,1),(1,2)], 
    [(1,0),(1,1),(0,1),(0,2)]
]

def solve():
    for i in range(n):
        for j in range(m):
            find(i,j)

def find(x,y):
    global answer
    for i in range(19): # 모든 가능한 테트로미노의 19가지 모양
        result = 0 # 각 테트로미노의 합산 값
        for j in range(4):  # 테트로미노는 4개의 블럭
            try:
                next_x = x+tetromino[i][j][0] # 현재 위치에서 테트로미노를 놓은 x 좌표
                next_y = y+tetromino[i][j][1] # 현재 위치에서 테트로미노를 놓은 y 좌표
                result += board[next_x][next_y] # 합산 값을 구함
            except IndexError: # 현재 위치에서 테트로미노가 board 밖으로 나가게 된다면 인덱스 에러 발생
                continue
        answer = max(answer,result)

answer = 0
solve()
print(answer)